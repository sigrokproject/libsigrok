my serial: 02540002a16  << just usb descriptro iserial
usb controller version: 0.0.4 << bcdDevice from descriptor is 0.04
scope controller: c4548fc1

Schematic http://wiki.lab-nation.com/images/8/88/SmartScope_Schematics_v1.1.pdf
http://www.microchip.com/wwwproducts/en/PIC18F14K50

PIC is on USB.  3 endpoints,
DATA = in/0x81
CMD_OUT = out/ 0x2
CMD_IN = in /0x83
in/out for "control" (someone didn't quite understand USB methinks) and 1 in for the data acquisition.

"targets" are (ScopeController.xxxx)
PIC
ROM 
FLASH (ignore, seems to be mostly calibration settings)
FPGA => use this a lot!
AWG


PIC has an i2c interface to FPGA.
FPGA  has (at least) 3 virtual i2c addresses.
0x0c - fpga settings
0x0d - "rom" ( read via the "FPGA" "target" above, not ROM, that's pic internal?
0x0e - Waveform generation (AWG) module

Then also commands for "flash" and "rom" (which seem to be pic internal eeprom and flash?, it has both)

PIC also has a "wide" 8bit data bus (plus some control pins) presumably for sucking the data out)

ADC and all of aux connector all connected to FPGA side
ADC is MAX19506

setup/command stuff consists of sending data on the CMD_OUT, with target/address/data information, and the PIC onboard routes it "appropriately"
Mix of high level and very low level commands available.
USB commands are (mostly) in src/Hardware/SmartScopeInterfaceUsb.cs
but that only gets you the top level routing.  Lower level interfaces are further down in each separate module.  (As befitting the style of multiple virtual devices)


i2c read requires writing regs
then reading back

write is cmdbyte, i2c_write, i2caddress<<1, regaddress inside fpga


normal "setcontrolregister" (for doing an i
headerr = ctrl, write, address, length


"reading fpga rom reg 0"
=> getControllerReg(FGPA, "convertAddress(0)", out data)
=> getControllerReg(FPGA, 0 + 0xd<<8)
=>
 => setControllerReg(fpga, 0xd<<8|reg, null)
  => USBCommandHeader(fpga, WRITE, 0xd<<8|reg, 0)
   => usbCommmandHeaderI2C(address >> 8 & 0x7f), WRITE, address&& 0xff, len=0) 
     => HDR_CMD, I2C_write, 0+2, 0xd<<1, reg
  => write to CMD_OUT
 => USBCommandHeader(fpga, READ, 0xd<<8|reg, len=1)
   => usbCommmandHeaderI2C(address >> 8 & 0x7f), READ, address&& 0xff, len=1) 
     => HDR_CMD, I2C_READ, address>>8 (i2caddress => 0xd), len=1
 => write header from above to cmd_out
 => read 16 from cmd_in





in CXX, all they expose is
and that's enough to do the rest! (app is clever enough to know address and len and data.
SET:
            _scope->SetControllerRegister(ctrl_msg->ctrl, ctrl_msg->addr, ctrl_msg->len, ctrl_msg->data);

and GET:
            _scope->GetControllerRegister(ctrl_msg->ctrl, ctrl_msg->addr, ctrl_msg->len, ((ControllerMessage*)response->data)->data);

